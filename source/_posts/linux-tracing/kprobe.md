---
title: kprobe
---



# Kprobe





## 1. kprobe 是什么



不知道大家对于可执行程序是如何理解的，在我看来，可以有两种视角：

1. 未执行时。按照一定的格式，存放在某个文件中；
2. 执行时。操作系统将程序加载到内存当中执行，赋予 text 节可读可执行权限，赋予 data 节可读可写权限 ... 



正因为可执行程序最终一定会加载到内存当中执行，内存我们是可以任意修改的，这样就可以玩出很多花样，kprobe 就是其中之一。



kprobe 顾名思义，kernel probe，内核探针，是一种动态的探测机制（当然不止于探测），相比于静态打点，这种方式更加灵活，几乎可以应用于各个场景，因此也被称为 **动态探针**



那么其 **动态** 特性是如何实现的呢？诶，这就是我们上面提到的，修改可执行文件对应代码段的内容！



## 2. kprobe 实现原理



有的同学可能很诧异，what？代码段还能修改？不是只有可读可写的数据段之类的，才能修改其中的内容吗？Too young too simple

只要是内存中的东西，内核都有办法将其修改掉，只不过，这种手段并不会轻易暴露给用户，否则可不把系统玩崩了



### 2.1 register_kprobe



做了下面几件事：

1. 根据符号获取 kprobe 的地址，或者直接获取到传入参数中的 kprobe 地址
2. 准备一个可执行 mmap 区间中的 slot，并且将被 probe 的指令保存到 slot 中
3. 添加这个 kprobe 到全局的 kprobe 哈希表中
4. 通过 arm_probe 将对应位置上的指令的第一个字节替换为 0xcc



如此一来，执行到这个 kprobe 之后，就会触发 int3 trap，就会陷入内核设置的 int3 处理函数中，即 `do_int3`



### 2.2 kprobe_int3_handler



做了下面几件事：

1. 执行 pre_handler
2. 设置单步中断标志位
3. 将 pt_regs 中的 ip 指向保存的指令地址



```markdown
Tips:
	1. 注意，此时已经将被修改指令的第一个字节修改为 0xcc(int3)，如果该指令的地址为 x,那么此时的 ip = x + 1
	2. 因为单步中断是完全可控的，所以可以将 ip 指向我们保存在可执行段中的指令，之后再将 ip 重新指回去就好了
```





### 2.3 kprobe_debug_handler



重置该 kprobe，并且修正一些由于上一条指令执行导致的问题：

1. 函数调用



之所以要修正，主要是因为如果我们刚好将一条 `call %rip(xxx)` 执行的第一个字节修改为 `0xcc` 了，在单步执行之后，就会将返回地址压栈，压栈的地址又是通过当前的 EIP 来决定的，但此时的 EIP 已经不是正常执行流中的预期值了，这样，函数调用返回之后，return 直接爆炸

因此，这里有必要修正一下位于栈顶的 return_address



### 2.4 unregister_kprobe



做了几件事：

1. 弹出对应指令地址处，最上方的一个 kprobe 探针
2. 对于弹出的探针，将其禁止，也就是通过 `disarm_kprobe` 将原先指令还原





