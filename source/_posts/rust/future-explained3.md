---
title: future explained(3) 
date: 2021-11-24 14:01:29
categories: "rust future"
---



# future explained(3)  -- Pin å¿ƒè·¯å†ç¨‹

withoutboats æ˜¯ Rust å¼‚æ­¥çš„ä¸»è¦è´Ÿè´£äººï¼Œä»–åœ¨ä¸€æ¬¡åˆ†äº«ä¸­è¯¦ç»†æè¿°äº† Pin çš„æ¼”å˜è¿‡ç¨‹å’ŒèƒŒåçš„å¿ƒè·¯å†ç¨‹



## ä¸€. Future æ¨¡å¼å¼•å…¥

åœ¨ Rust ä¹‹å‰çš„å¾ˆå¤šè¯­è¨€ï¼Œç»å¤§å¤šæ•°é€‰æ‹©äº†å›è°ƒæœºåˆ¶å®ç°çš„å¼‚æ­¥é€»è¾‘ï¼Œæ¯”å¦‚Cè¯­è¨€ä¸­çš„ libeventï¼Œå†è¿˜æœ‰ nodejs ä¸­çš„ callbackã€‚  
é¦–å…ˆåœ¨ Rust ä¸­ï¼Œä½ å¾ˆéš¾å†™å‡º `nodejs` é‚£ç§å›è°ƒæ¨¡å¼çš„å¼‚æ­¥ä»£ç ï¼Œä¸‹é¢æ˜¯ä¸€å°æ®µå…¸å‹çš„ `nodejs` å›è°ƒæ¨¡å‹

```rust
fn get_foos(client: Client) -> impl Future<Output = Vec<Response>>{
    client.get_index("/foos").and_then(|index|{
        client.get_responses(&index).collect()
    })
}
```



åœ¨ Rust ä¸­ï¼Œä¸”ä¸è¯´å›è°ƒåœ°ç‹±é—®é¢˜ï¼Œå…³é”®æ˜¯è¿™ç§å†™æ³• **æ ¹ æœ¬ ç¼– è¯‘ ä¸ è¿‡!**

è¿™æ®µä»£ç ï¼Œåœ¨ Rust ä¸­å­˜åœ¨å¾ˆä¸¥é‡çš„æ‰€æœ‰æƒå’Œç”Ÿå‘½å‘¨æœŸé—®é¢˜ï¼Œä½ ä¼šå¾—åˆ°å„ç§å„æ ·çš„ç¼–è¯‘é”™è¯¯ã€‚æ ¹æ® rustc çš„æç¤ºï¼Œç¼ç¼è¡¥è¡¥ï¼Œä½ æˆ–è®¸ä¼šç”¨ä¸‹é¢è¿™ç§æ–¹å¼å»å¤„ç†ï¼Œä¹Ÿç¡®å®å¯ä»¥ç¼–è¯‘ï¼Œä½†ä¹Ÿä»…æ­¤è€Œå·²ã€‚ä¸”ä¸è¯´ä¸ºäº†ç¼–è¯‘é€šè¿‡è€Œä»˜å‡ºçš„åŠªåŠ›ï¼Œå•å•æ˜¯ Arc å’Œ Mutex å¸¦æ¥çš„é¢å¤–å¼€é”€ï¼Œä¹Ÿæ˜¯æ— æ³•æ¥å—çš„ã€‚å½“åˆ›å»ºå¤§å‹ç¨‹åºæ—¶ï¼Œç®€ç›´æ— æ³•æƒ³è±¡ã€‚ 

```rust
fn get_foos(client: Client) -> impl Future<Output = Vec<Response>>{
    let client: Arc<Mutex<Client>> = Arc::new(Mutex::new(Client));
    let client2 = client.clone();

    client.lock().unwrap().get_index("/foos").and_then(move |index|{
        client2.lock().unwrap().get_responses(&index).collect()
    })
}
```



å› æ­¤ï¼ŒRust å›¢é˜Ÿè¿›è¡Œè®¾è®¡äº†ä¸€å¥—åŸºäº Future çš„ APIï¼Œæå‡ºäº† async/await è¿™ç»„å…³é”®å­—ï¼Œå°†å¼‚æ­¥ä»£ç è½¬æ¢æˆåŒæ­¥æ¨¡å‹ï¼Œè¿™ä¸ä»…å›é¿äº†ä¸Šé¢çš„æ‰€æœ‰æƒé—®é¢˜ï¼Œè¿˜æ›´åŠ ç¬¦åˆäººä½“å·¥ç¨‹å­¦ã€‚ 

è¿™ç§å†™æ³•éå¸¸æ¥è¿‘ `blocking io`ï¼Œç¨‹åºå‘˜èƒ½è½»æ˜“çœ‹å‡ºæ‰§è¡Œçš„é€»è¾‘ï¼Œå´èƒ½å¤Ÿä»¥å¼‚æ­¥çš„æ–¹å¼è¿è¡Œï¼Œè¿™ä¸»è¦å½’åŠŸäº Rust ç¼–è¯‘å™¨å¯¹äº async ä»£ç å—çš„é«˜çº§æŠ½è±¡ï¼Œasync block ä¼šè¢«ç¿»è¯‘æˆä¸€ä¸ª**çŠ¶æ€æœº GenFuture**ï¼ˆåŒ¿åç»“æ„ä½“ï¼‰ï¼Œå¹¶ä¸”å…¶ä¸­ä»»ä½•è·¨è¶Š await ä»£ç å—çš„å¼•ç”¨ï¼Œéƒ½ä¼šå°†è¢«å¼•ç”¨çš„å˜é‡å’Œå¼•ç”¨ä¿å­˜åˆ°å½“å‰ä¸º async ä»£ç å—ç”Ÿæˆçš„çŠ¶æ€æœºä¸­ï¼Œæ¯ä¸€ä¸ª await ç‚¹éƒ½æ˜¯çŠ¶æ€çš„è½¬å˜æ—¶æœºã€‚  


è¿™æ ·çš„è®¾è®¡æ˜¯ååˆ†ä¼˜é›…çš„ï¼Œä¹Ÿéå¸¸æœ‰æ•ˆï¼Œä½†æ˜¯å´å¸¦æ¥äº†ä¸€ä¸ªé—®é¢˜ï¼š**è‡ªå¼•ç”¨** ã€‚æ¥çœ‹ä¸‹é¢è¿™ä¸ªä¾‹å­ï¼š  

```rust
async fn get_foos(client: Client) -> Vec<Response>{
    let index = client.get_index("/foos").await; // State { Client, &mut Client}
    client.get_responses(&index).collect().await
}
```



ä¸Šé¢çš„ä»£ç ä¸­ï¼Œ`let index = client.get_index("/foos").await;` å­˜åœ¨ä¸€ä¸ªè·¨è¶Š await å…³é”®å­—çš„å¯¹äº client çš„å¼•ç”¨ï¼Œå› æ­¤ï¼Œå¿…é¡»è¦å°† client å’Œ &mut client éƒ½ä¿å­˜åœ¨çŠ¶æ€æœºä¸­ã€‚ï¼ˆè¿™é‡Œä¸å»è€ƒè™‘æ‰‹åŠ¨æ„é€ çš„é—®é¢˜ï¼Œéœ€è¦ unsafe ä»£ç æ“ä½œè£¸æŒ‡é’ˆæ‰å¯ä»¥ï¼Œç¼–è¯‘å™¨å®ç°èµ·æ¥ä¼šè½»æ¾å¾ˆå¤šï¼‰

å¦‚æœæŒ‰ç…§æœ€åŸå§‹çš„ Future æ¥å£( `fn poll(&mut self, ctx: &mut Context<'_>)`)ï¼Œæˆ‘ä»¬å¾ˆè½»æ˜“å°±èƒ½åœ¨å®‰å…¨ä»£ç ä¸­è®© Rust ç¨‹åºå´©æºƒï¼š

```rust
fn bar(){
    let mut future = get_foos(...);
    future.poll(...);
    let mut future2 = get_foos(...); // ä¸ºäº†é˜²æ­¢ let mut future2 = future åªæ˜¯ä¸€ä¸ªåˆ«åï¼Œå¼ºåˆ¶åˆå§‹åŒ– future2ï¼Œä»è€Œä¸‹é¢çš„ future2 = future æˆä¸ºä¸€ä¸ª memcpy æ“ä½œ
    future2 = future;       // è‡ªå¼•ç”¨ç»“æ„å·²ç»å¤±æ•ˆï¼Œå› ä¸º future å’Œ future2 éƒ½æ˜¯æ ˆä¸Šçš„ç»“æ„
    future2.poll(...); // æ­¤æ—¶å®Œå…¨æ— æ³•æ§åˆ¶ poll ä¸­æ˜¯å¦ä¼šä½¿ç”¨è¯¥å¤±æ•ˆçš„è‡ªå¼•ç”¨ ï¼Œ
                       // äº§ç”Ÿäº† undefined behavior
}
```

ä¸Šé¢ä»£ç å­˜åœ¨çš„é—®é¢˜æ˜¯ï¼šå½“ poll ä¸€ä¸ª Future ä¹‹åï¼Œæˆ‘ä»¬ç§»åŠ¨äº†å®ƒåŸæœ¬çš„ä½ç½®ï¼Œå¯¼è‡´ Future ä¸­çš„**è‡ªå¼•ç”¨ç»“æ„å¤±æ•ˆ**ã€‚ 

è¿™ä¼¼ä¹æœ‰ä¸€ç‚¹è«åå…¶å¦™ï¼Œæ·±ç©¶ä¸€ä¸‹æ ¹æºï¼Œä½ ä¼šå‘ç°ï¼Œè¿™å’Œå †ã€æ ˆçš„ç‰¹æ€§æœ‰å…³ã€‚ 

åœ¨æ ˆä¸Šåˆ†é…çš„å˜é‡ï¼Œå¦‚æœç§»åŠ¨äº†æ‰€æœ‰æƒï¼Œå…¶å¤§æ¦‚ç‡ï¼ˆå¦‚æœä¸æ˜¯é€šè¿‡åˆ«åå¤ç”¨è¿™å—å†…å­˜çš„è¯ï¼‰ä¹Ÿä¼šé‡æ–°åˆ†é…ä¸€å—å†…å­˜ï¼Œå¹¶ä¸”åŸå…ˆçš„å†…å­˜ä¼šå¤±æ•ˆã€‚å‚ç…§ä¸‹å›¾ï¼Œåœ¨ `state2 = state1;` ä¹‹åï¼Œä¼šå°† state1 ä¸­çš„å†…å®¹å®Œå®Œæ•´æ•´æ‹·è´åˆ° state2 ä¸­ï¼Œä½†æ˜¯ State ä¸­çš„ `&mut client`ï¼Œè¿˜æŒ‡å‘ state1 é‚£å—å·²ç»å¤±æ•ˆçš„å†…å­˜ï¼Œè¿™æ‰äº§ç”Ÿçš„ UB è¡Œä¸º

<div align=center>
<img height=70% width=70% src="/images/pin1.png" />
<br/>
<br/>
</div>
è§£å†³çš„åŠæ³•å¾ˆç®€å•ï¼šå †å†…å­˜åˆ†é…ï¼ 

å¦‚æœæˆ‘ä»¬åœ¨æ ˆä¸Šåªä¿ç•™ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘å †ä¸Šåˆ†é…çš„ Stateï¼Œé‚£ä¹ˆï¼Œå½“æ‰€æœ‰æƒå‘ç”Ÿè½¬ç§»çš„æ—¶å€™ï¼Œä»…ä»…æ˜¯ä¹‹å‰è¿™ä¸ªæŒ‡é’ˆå¤±æ•ˆäº†ï¼Œå †ä¸Šçš„**å€¼å¼•ç”¨ç»“æ„**å¹¶æ²¡æœ‰ç§»åŠ¨ï¼Œä¹Ÿæ²¡æœ‰è¢«é‡Šæ”¾ï¼Œä»ç„¶æ˜¯æœ‰æ•ˆçš„ã€‚

<div align=center>
<img height=70% width=70% src="/images/pin2.png" />
<br/>
<br/>
</div>

è¿™ç§æ¨¡å¼ï¼Œå°±å¥½åƒå°† State é’‰(Pin)åœ¨äº†å †ç©ºé—´ä¸­ï¼Œæ— è®ºæ ˆä¸Šçš„æŒ‡é’ˆæ€ä¹ˆç§»åŠ¨ï¼Œå †ä¸Šçš„å†…å­˜éƒ½ä¸ä¼šå—åˆ°åŠç‚¹å½±å“ã€‚

```rust
let state3 = state2;
let state4 = state3; // totally fine
...

```

## äºŒ. Future æ”¹è¿›ï¼ŒPin å¼•å…¥

withoutboats ä½œä¸º Rust å¼‚æ­¥æœºåˆ¶çš„ä¸»è¦è®¾è®¡è€…ï¼Œé’ˆå¯¹åŸå§‹çš„ Future trait æå‡ºäº†å‡ ä¸ªæ–¹æ¡ˆï¼š

### 1. unsafe æ ‡è®°

è¿™ä¸ªæ–¹æ¡ˆè§£å†³çš„æ€è·¯æ˜¯ï¼šä¸ºäº†ä½¿ç”¨ Futureï¼Œä½ å¿…é¡»è¦ç¡®ä¿ SAFETYï¼šè¯¥ Future ä¸€æ—¦è¢« poll ä¹‹åï¼Œç›´åˆ°å…¶è¢« Drop éƒ½ä¸ä¼šè¢«ç§»åŠ¨ã€‚  
å¯¹äºåˆ†é…åœ¨å †ä¸Šçš„ future å¤©ç”Ÿå°±æ»¡è¶³è¿™ä¸€ç‚¹è¦æ±‚ï¼Œæ‰€ä»¥è¿™ä¸»è¦æ˜¯é’ˆå¯¹åœ¨æ ˆä¸Šçš„å†…å­˜è€Œè¨€çš„çº¦æŸã€‚ 

è™½ç„¶è¿™ç¡®å®å¯ä»¥è§£å†³ç°é˜¶æ®µ Future ç§»åŠ¨å¯¼è‡´çš„é—®é¢˜ï¼Œä½†è¿™ä¼šå¸¦æ¥ä¸€ä¸ªä¸å¾—ä¸è€ƒè™‘çš„é—®é¢˜ï¼šæœ¬å°±ä¸å—å¤§å®¶æ¬¢è¿çš„ unsafe å¯èƒ½ä¼šéå¸ƒä»£ç åº“ï¼è€Œä¸”ç›¸å½“äºæŠŠé”…éƒ½ç”©ç»™äº†ç”¨æˆ·ï¼Œå¤§å¤§åŠ é‡äº†å¼€å‘äººå‘˜å¿ƒæ™ºè´Ÿæ‹…ï¼Œè¯¥æ–¹æ¡ˆä½œä¸ºé’ˆå¯¹ Future æ¥å£çš„ç¬¬ä¸€æ¬¡æ”¹è¿›ï¼Œä¹Ÿå°±åˆ°æ­¤ä¸ºæ­¢ã€‚

```rust
pub trait Future{
    type Output;

    unsafe fn poll(&mut self, ctx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

### 2. Pin çš„åŸå§‹ç‰ˆæœ¬

unsafe Future Trait çš„æ–¹æ¡ˆè¢« pass ä¹‹åï¼ŒRust å›¢é˜Ÿå¼€å§‹å¯»æ±‚åˆ«çš„è§£å†³æ–¹å¼ï¼Œå¹¶æå‡ºäº† Pin çš„æ¦‚å¿µã€‚ 

ä½† Pin æœ€ä¸€å¼€å§‹å¹¶ä¸åƒç°åœ¨è¿™æ ·ç®€æ´ï¼Œå…¶ä¹Ÿæ˜¯ç»å†äº†å¾ˆå¤šè®¾è®¡ä¸Šçš„æ”¹è¿›ã€‚æœ€ä¸€å¼€å§‹çš„è®¾è®¡å…¶å®é•¿ä¸‹é¢è¿™æ ·ï¼š

```rust
pub struct PinMut<'a, T>(&'a mut T);

impl<'a, T> PinMut<'a, T> {
    pub unsafe fn get_mut_unchecked(self) -> &'a mut T{
        self.0
    }
}

pub struct PinBox<T>(Box<T>);

impl<T> From<Box<T>> for PinBox<T> {
    fn from(b: Box<T>) -> PinBox<T> {
        PinBox(b)
    }
}

impl<T> PinBox<T> {
    pub fn as_mut<'a>(&'a mut self) -> &'a mut T{
        PinMut(&mut *self.0)
    }
}

pub trait Future{
    type Output;

    fn poll(self: PinMut<'_, Self>, ctx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

è¿™é‡Œå¼•å…¥äº† `PinBox` å’Œ `PinMut` ä¸¤ä¸ªæ¦‚å¿µï¼Œéƒ½æ˜¯å¯¹äºæŒ‡é’ˆçš„å°è£…ï¼Œæœ€å¤§çš„ä¸åŒæ˜¯ï¼Œå¦‚æœæƒ³è¦é€šè¿‡ `PinMut` è·å–åˆ°èƒŒåçš„æŒ‡é’ˆï¼Œå¿…é¡»è¦é€šè¿‡éå®‰å…¨æ–¹æ³•å®Œæˆï¼Œè€Œå¯¹äº `PinBox` è€Œè¨€ï¼Œåˆ™æ˜¯å¯ä»¥ç›´æ¥åœ¨å®‰å…¨ä»£ç ä¸­è·å– Box èƒŒåçš„å¯¹è±¡æŒ‡é’ˆã€‚  

è¿™ç§å°è£…ï¼Œå¸¦æ¥äº†ä¸€ä¸ªå¾ˆå¤§çš„å¥½å¤„ï¼šå¦‚æœæƒ³è¦é€šè¿‡ PinMut è·å–èƒŒåçš„å¼•ç”¨ï¼Œåªèƒ½é€šè¿‡ get_mut_unchecked è¿™ç§ unsafe çš„æ–¹å¼ï¼Œé‚£ä¹ˆï¼Œå½“æˆ‘ä»¬å°† Future çš„ self ç±»å‹é™å®šä¸º `PinMut<'_, Self>` çš„æ—¶å€™ï¼Œå°±ä¼šå‘ç°ï¼Œå¹¶ä¸æ˜¯é‚£ä¹ˆè½»æ˜“å°±èƒ½è·å–åˆ° `&mut self` çš„å“¦ï¼Œå¿…é¡»è¦ç¡®ä¿è¿™ä¸ªæ“ä½œçš„ **SAFETY**ï¼Œä¹Ÿå°±ä¸å¯èƒ½åœ¨å®‰å…¨ä»£ç ä¸­ï¼Œç›´æ¥è·å–åˆ° &mut selfï¼Œç»§è€Œå¯¼è‡´ future ä¸­å†…å®¹è¢«è½»æ˜“ç§»åŠ¨ã€‚å¹¶ä¸”ï¼ŒåŸºäºè¿™ä¸¤ä¸ªæŠ½è±¡ï¼Œæ­£ç¡®æ€§è¯æ˜èµ·æ¥æ˜¯æ¯”è¾ƒå®¹æ˜“çš„ã€‚    

```rust
let a = PinMut(&mut p);
// error to compile
mem::swap(a.get_mut_unchecked(),&mut something_else);
// ok to compile, but usage of unsafe is wrong
mem::swap(unsafe { a.get_mut_unchecked() },&mut something_else);

```

è¿™æ®µè¯ä¸­è¿˜å¼•å…¥äº†ä¸€ç‚¹ï¼Œå¦‚æœèƒ½å¤Ÿåœ¨å®‰å…¨ä»£ç ä¸­ï¼Œè·å–åˆ°è‡ªå¼•ç”¨ç»“æ„çš„å¯å˜å¼•ç”¨ï¼Œä¹Ÿä¼šå¯¼è‡´ Rust ç»™æˆ‘ä»¬åšå‡ºçš„å®‰å…¨è§„èŒƒè½°ç„¶å€’å¡Œ
ç»“åˆä¹‹å‰çš„å †ã€æ ˆåˆ†é…çš„ç‰¹ç‚¹ï¼Œå®é™…ä½¿ç”¨ä¸­ï¼Œä¼šå…ˆå°†å…¶åˆ†é…åœ¨å †ä¸Šï¼Œä¿è¯ä¸ä¼šå› ä¸º `let mut future2 = future1;` è¿™ç§è¯­ä¹‰å°†å…¶ç§»åŠ¨ï¼Œå…¶æ¬¡ï¼Œå°±æ˜¯éµå®ˆ PinMut ç»™æˆ‘ä»¬çš„çº¦æŸï¼Œä¿è¯ä¸ä¼šè·å–åˆ°å¯å˜å¼•ç”¨è€Œç§»åŠ¨ã€‚ 

ç›¸æ¯”å¦‚ç¬¬ä¸€ä¸ª unsafe ææ¡ˆï¼Œæˆ‘ä»¬è™½ç„¶å…ä¸äº†å’Œ unsafe æ‰“äº¤é“ï¼Œä½†æ˜¯å·²ç»å¯ä»¥å¾—åˆ°ä¸€ä¸ªéå¸¸å¹²å‡€çš„ Future æ¥å£ï¼Œè°ƒç”¨ poll ä¹Ÿä¸éœ€è¦å†ç”¨ unsafe æ¥æ–¹å¼è¯¯ç”¨äº†ï¼Œç›¸å½“äºæ˜¯å°† unsafe é€»è¾‘è½¬ç§»åˆ°äº†å†…å±‚å®ç°ä¸­ã€‚

```rust
pub fn spawn<F: Future>(f: F){
    let mut fut = PinBox::from(Box::new(f));
    
    // safe the fut to somewhere

    // handin to the executor

    // construct PinMut, then poll
    fut.as_mut().poll(...);
} 
```

ä½†å³ä½¿æ˜¯å†…å±‚çš„ unsafe é€»è¾‘ï¼Œä¹Ÿä¼šç»™å¼€å‘äººå‘˜å¸¦æ¥å¾ˆå¤§çš„å¿ƒæ™ºè´Ÿæ‹…ï¼ 

åœ¨ä¸Šé¢çš„çº¦æŸä¸‹ï¼Œæˆ‘ä»¬å¦‚æœæƒ³è¦åœ¨ poll æ–¹æ³•ä¸­æ›´æ–° self çš„çŠ¶æ€ï¼Œæˆ–è€…è°ƒç”¨ self æŸä¸€äº› field çš„æ–¹æ³•ï¼Œéƒ½è¦é¦–å…ˆé€šè¿‡éå®‰å…¨ä»£ç ï¼Œè·å– &mut Selfï¼Œç›¸å½“äºå£°æ˜ï¼šæˆ‘éµå®ˆ unsafe èµ‹äºˆæˆ‘çš„ä¸€åˆ‡æƒåŠ›ï¼Œæˆ‘ä¿è¯ä¸ä¼šç§»åŠ¨ selfã€‚

```rust
struct AsyncIoHandle{
    pub fn poll_read(&mut self,buf: &mut [u8]) ->Poll<usize>{
        ...
    }
}

struct IoFuture {
    buf: Vec<u8>,
    file: AsyncFileHandle
}

impl Future for IoFuture {
    tyep Output = usize;

    fn poll(self: PinMut<'_, Self>, x: &mut Context<'_>) -> Poll<Self::Output>{
        // wont't compile 
        // self.file.poll_read(&mut self.buf[..]) 

        unsafe {
            let this: &mut Self = self.get_mut_unchecked();
            this.file.poll(&mut this.buf[..]);
        }
    }
}
```

è¿™ç§æ¼äººçš„é—®é¢˜å¯¹äº **Leaf Future** å°¤ä¸ºä¸¥é‡ã€‚æ‰€è°“çš„ **Leaf Future**ï¼Œå…¶å®æ˜¯é¢å‘åº•å±‚ Io(reactor)ã€éœ€è¦æ‰‹åŠ¨å®ç°çš„ Futureï¼Œ**Non-Leaf Future** å°±æ˜¯é€šè¿‡ async await è‡ªåŠ¨ç”Ÿæˆçš„ Futureï¼ŒåŒ…å«äº†ä¸‹é¢çš„æ‰€æœ‰ç»“ç‚¹ï¼Œnon-leaf or leafã€‚æ›´ä»¤äººæ— å¥ˆçš„ä¸€ç‚¹æ˜¯ï¼Œå¯¹äº 99% æ‰‹åŠ¨å®ç°çš„ `Leaf Future`ï¼Œå¹¶æ²¡æœ‰ `self referential` çš„é—®é¢˜ï¼Œä»éœ€è¦ä½¿ç”¨ unsafeã€‚  async/await ä¸­çš„ `self referential` ç®—æ˜¯è§£å†³ï¼Œä½†åˆå‘åŠ›è¿‡çŒ›ï¼Œä¸€æ£’å­æ‰“æ­»äº†æ›´å¤šçš„ **good future**ã€‚

æ€»ç»“ä¸€ç‚¹ï¼š**ç›®å‰ä¸ºæ­¢ï¼Œé€šè¿‡ PinMut å’Œ PinBox çš„æŠ½è±¡ï¼Œå·²ç»è§£å†³äº† executor ä¸­çš„é—®é¢˜(æ¯”å¦‚éœ€è¦ä½¿ç”¨ unsafe)ï¼Œæä¾›äº†æ˜“ç”¨çš„ Future::poll æ¥å£ï¼Œä½†æ˜¯å¯¹äº reactor ä»æ— å¤ªå¥½çš„åŠæ³•ã€‚PinMut å’Œ PinBox çš„æ­£ç¡®æ€§æ˜¯æ¯‹åº¸ç½®ç–‘çš„**  

### 3. Unpin çš„å¼•å…¥

ä¸ºäº†è§£å†³ä¸Šé¢çš„é—®é¢˜ï¼Œwithoutboats å¼•å…¥äº† Unpin çš„æ¦‚å¿µã€‚  

Unpin æ˜¯ä¸€ä¸ª auto traitï¼ŒRust é»˜è®¤ä¸ºæ‰€æœ‰ç»“æ„éƒ½æ·»åŠ äº†è¿™ä¸ªæ ‡è®° Traitï¼ˆåƒ Send å’Œ Syncï¼‰ï¼Œä½†æ˜¯ï¼Œå¦‚æœä¸€ä¸ªç»“æ„åŒ…å«äº† !Unpin çš„å­—æ®µï¼Œé‚£ä¹ˆå…¶è‡ªèº«ä¹Ÿæ˜¯ !Unpinï¼ˆ !Unpin å±æ€§ä¼šä¼ æ’­ï¼‰ï¼Œå‡ ä¹å”¯ä¸€çš„ !Unpin ç»“æ„å°±æ˜¯ç¼–è¯‘å™¨ä¸º async ä»£ç å—ç”Ÿæˆçš„ GenFutureã€‚å…¶ä½™æ‰€æœ‰çš„åŸºç¡€ç»“æ„ï¼ŒåŒ…æ‹¬ i32, usize éƒ½æ˜¯ Unpin çš„ç»“æ„ï¼Œæ¯”è¾ƒç‰¹æ®Šçš„æ˜¯å¯¹äºå¤æ‚çš„è‡ªå¼•ç”¨ç»“æ„çš„æŒ‡é’ˆã€‚  

å¯¹äºå†…éƒ¨åŒ…å«äº† Unpin ç»“æ„çš„ PinMutï¼Œåªéœ€è¦ä¸ºå…¶å®ç° DerefMut æ–¹æ³•ï¼Œå°±å¯ä»¥ç›´æ¥è·å–åˆ° &mut Tï¼ŒPinMut<'a,T> å’Œ &mut Tï¼Œä¹Ÿå°±ä¸éœ€è¦çƒ¦äººçš„ unsafe äº†! ä¹Œæ‹‰ï¼   

```rust
pub auto trait Unpin {}

impl<'a, T: Unpin + ?Sized> DerefMut for PinMut<'a,T>{
    type Target = T;

    fn deref_mut(&mut Self) -> &mut Self::Target{
        ...
    }
}

```

3. æœ€ç»ˆæ–¹æ¡ˆ Pin

æœ€ç»ˆå¼•å…¥æ ‡å‡†åº“çš„æ–¹æ¡ˆå¹¶ä¸æ˜¯ä¸Šé¢çš„ PinMut + PinBoxï¼Œè€Œæ˜¯æ›´åŠ ç®€æ´çš„ä¸€ä¸ªç»Ÿä¸€æ¥å£ï¼š **Pin**  

Pin ä¹Ÿæ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå†…å±‚åŒ…è£…äº†ä¸€ä¸ªæŒ‡é’ˆï¼Œé’ˆå¯¹å†…éƒ¨ä¸åŒçš„æŒ‡é’ˆç±»å‹ï¼Œå®ç°äº†ä¸åŒçš„ traitã€‚ 

æ ‡å‡†åº“ä¸­æœ‰ä¸‹é¢å‡ ä¸ªå…³é”®çš„å‡½æ•°ï¼Œéƒ½å¯¹å®ƒä»¬åšäº†æ³¨è§£ï¼š  

```rust
pub struct Pin<P>{
    pointer: P
}

// ç›´æ¥é€šè¿‡è£¸æŒ‡é’ˆåˆ›å»º Pin æ˜¯ä¸å®‰å…¨çš„ï¼Œä½¿ç”¨è€…å¿…é¡»è¦ç¡®ä¿ï¼Œè¿™ä¸ªæŒ‡é’ˆæ˜¯æœ‰æ•ˆçš„!
impl Deref<P: Deref> Pin<P>{
    pub unsafe fn new_unchecked(pointer: P) -> Pin<P> {
        Pin { pointer }
    }
}

// åŒç†ï¼Œå°† Pin è½¬æ¢æˆå†…éƒ¨çš„è£¸æŒ‡é’ˆï¼Œä¹Ÿæ˜¯ä¸å®‰å…¨çš„!
impl<'a, P> Pin<'a mut P>{
    pub unsafe fn get_unchecked_mut(self) -> 'a mut P {
        self.pointer
    }
}

// Target::Unpin çš„æŒ‡é’ˆ Pï¼Œå¯ä»¥å®‰å…¨è·å– &mut P::Target
impl<P: DerefMut<Target: Unpin>> for Pin<P> {
    fn deref_mut(&mut self) -> &mut P::Target {
        Pin::get_mut(Pin::as_mut(self))
    } 
}

// å¦‚æœè¦ä» Pin<P> åˆ›å»ºå‡º Pin<&'a mut P::Target>ï¼Œè¿˜æ˜¯å¯ä»¥åŠåˆ°çš„
// å› ä¸º Pin å§‹ç»ˆæœ‰è¿™ä¸ªæŒ‡é’ˆçš„æ‰€æœ‰æƒï¼Œæ‰€ä»¥ä¸éœ€è¦æ‹…å¿ƒä¼šå‡ºç° UB è¡Œä¸º
impl<P: DereMut> Pin<P> {
    pub fn as_mut<'a>(&mut self) -> Pin<&'a mut P::Target> {
        unsafe { Pin::new_unchecked(&mut *self.pointer) }
    }
} 

// ä» Box åˆ›å»º Pin æœ¬èº«å°±æ˜¯å®‰å…¨çš„ï¼Œå› ä¸º Box å®ç°äº† Unpin
impl<P> From<Box<P>> for Pin<Box<P>> {
    fn from(b: Box<P>) -> Pin<Box<P>>{
         unsafe { Pin::new_unchecked(b) }
    }
}
```

è¿™æ®µä»£ç å¯èƒ½æœ‰ä¸€ç‚¹ç»•ï¼Œä½†æ˜¯æ ¸å¿ƒå…³æ³¨ç‚¹å°±ä¸¤ä¸ª

1. å¯¹äºå®ç°äº† Deref ç±»å‹çš„ Pï¼Œæ˜¯å¦å¯ä»¥å®‰å…¨åœ°è·å–åˆ°å†…å±‚çš„è¿™ä¸ª pointer
2. å¯¹äºå®ç°äº† Deref ç±»å‹çš„ Pï¼Œæ˜¯å¦å¯ä»¥å®‰å…¨åœ°è·å–å†…å±‚ pointer æŒ‡é’ˆæŒ‡å‘çš„å¯¹è±¡

å§‹ç»ˆè¦ç‰¢è®° Pin çš„ä½¿å‘½ï¼šéœ€è¦ç¡®ä¿ Rust ä¸­ async/await ä»£ç ä¸­çš„è‡ªå¼•ç”¨ç»“æ„æœ‰æ•ˆï¼Œä¸èƒ½åœ¨ safe code ä¸­ crash Rust çš„å¼ºå®‰å…¨ä¿è¯ã€‚**è¿™æ®µä»£ç å…¶å®æ˜¯æœ‰é—®é¢˜çš„ï¼Œåé¢ä¼šæåˆ°**ã€‚

ç›®å‰çš„ Pin çš„è®¾è®¡ï¼Œæœ€æ ¸å¿ƒçš„ API æ˜¯ get_unchecked_mutï¼Œè¿™é‡Œçš„ **SAFETY** ä¿éšœæ˜¯ï¼šå¦‚æœ `<P as DerefMut>::Target ` æ˜¯ Unpinï¼Œé‚£ä¹ˆæ— æ³•é€šè¿‡å®‰å…¨æ‰‹æ®µå¾—åˆ°å…¶å¯å˜å¼•ç”¨ï¼Œå¦åˆ™å°±å¯èƒ½ç§»åŠ¨å…¶å†…å®¹ï¼Œå¯¼è‡´è‡ªå¼•ç”¨å¤±æ•ˆï¼ˆ99%çš„Unpinéƒ½å‘ç”Ÿåœ¨è‡ªå¼•ç”¨ç»“æ„ä¸Šï¼‰

ç»“åˆä¸Šé¢çš„ Unpin æ¦‚å¿µï¼Œæˆ‘ä»¬å¯ä»¥é’ˆå¯¹åŸºæœ¬ç±»å‹å’Œè‡ªå¼•ç”¨ç»“æ„åˆ†åˆ«æ¢è®¨ä¸€ä¸‹åˆç†æ€§ã€‚

åŸºæœ¬ç±»å‹æ˜¯ Unpin çš„ï¼Œå› æ­¤å¯ä»¥é€šè¿‡ `Pin::new` åˆ›å»ºï¼Œä¹Ÿå¯ä»¥é€šè¿‡ `b.get_mut()` è·å–å¯å˜å¼•ç”¨ï¼Œè·Ÿæ™®é€šä½¿ç”¨æŒ‡é’ˆæ²¡æœ‰ä»»ä½•åŒºåˆ«

```rust
let mut a = 1;
let b = Pin::new(&mut a);
let c = b.get_mut();
```

æ¥æ¥ä¸‹è€ƒè™‘ Pin åœ¨ async/await è¿™ç§è‡ªå¼•ç”¨ç»“æ„ä¸Šçš„è¿ç”¨ï¼ˆå‰ææ˜¯å·²ç»åˆ†é…åœ¨å †ä¸Šäº†ï¼‰ã€‚ä¸ºä»€ä¹ˆå¯¹äºä¸€ä¸ª `Box<impl Future<...>>`ï¼Œæˆ‘ä»¬ä¸åº”è¯¥å®‰å…¨çš„è·å–ä»£ç å—çš„å¯å˜å¼•ç”¨ï¼Ÿ

æ¢å¥è¯è¯´ï¼Œå¦‚æœæˆ‘ä»¬å¯ä»¥å®‰å…¨åœ°è·å–ï¼Œå¯èƒ½ä¼šæ€æ ·è¿èƒŒ Rust çš„å®‰å…¨å‡†åˆ™ï¼Ÿ  

```rust
let a = Box::new(async {}); // a is pined on the heap, but <A as DerefMut>::Target is still Unpin
let mut b = unsafe { Pin::new_unchecked(a) };
let c = b.as_mut();
// let d = c.get_unchecked_mut();
let d = unsafe { c.get_unchecked_mut() };

```

å¦‚æœå¯ä»¥å®‰å…¨è·å–åˆ° &mut GenFutureï¼Œä¸€æ—¦åœ¨ä¸¤æ¬¡ poll ä¹‹é—´ï¼Œè¢«ä¸çŸ¥æƒ…çš„ç”¨æˆ·é€šè¿‡ `mem::swap()` ç­‰æ‰‹æ®µå°†å…¶ç§»åŠ¨å‡ºå»ï¼Œå°±ä¼šå¯¼è‡´è‡ªå¼•ç”¨ç»“æ„å¤±æ•ˆ ğŸ’¥ ã€‚å› æ­¤ï¼Œ`Pin::get_mut_unchecked()` éœ€è¦é€šè¿‡ unsafe æ¥è®©ç”¨æˆ·è‡ªå·±åšå‡ºä¿è¯ã€‚

å‰é¢æˆ‘ä»¬ä¹Ÿæåˆ°ï¼Œå¦‚æœæƒ³è¦é€šè¿‡ `Pin::new()` è¿™ç§æ–¹å¼å®‰å…¨åœ°æ„é€  Pinï¼Œéœ€è¦ä¿éšœ `<P as DerefMut>::Target: Unpin`ï¼Œå¯¹äº Future æ¥è¯´ï¼Œä¹Ÿå°±åªèƒ½ç”¨ Box åŒ…è£…ä¸¤å±‚ï¼Œç¬¬ä¸€æ¬¡æ˜¯å¯¹å†…éƒ¨ Future çš„ Boxï¼Œç¬¬äºŒæ¬¡æ˜¯å¯¹æŒ‡å‘ `async {}` çš„æŒ‡é’ˆçš„ Boxï¼Œç„¶åæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ `b.as_mut().get_mut()` çš„æ–¹å¼å®‰å…¨åœ°è·å–åˆ° `&mut Box<...>`ï¼ŒWOWï¼æˆ‘ä»¬å¯ä»¥ç§»åŠ¨é‡Œé¢çš„ç»“æ„äº†è€¶ï¼é‚£ä¹ˆ Rust å´©äº†å—ï¼Ÿå°±è¿™ï¼Ÿ    


ç­‰ç­‰ï¼Œåˆ«é«˜å…´å¤ªæ—©ï¼Œæ³¨æ„åˆ° Future::poll çš„æ–¹æ³•ç­¾åï¼Œè¦æ±‚è¢« poll çš„ future å¿…é¡»è¦è¢« Pin ä¿æŠ¤èµ·æ¥ï¼Œæˆ‘ä»¬è¿™é‡Œå†æ€ä¹ˆç§»åŠ¨ Box é‡Œé¢çš„ Futureï¼Œéƒ½ä¸å¯èƒ½å½±å“ Future::pollã€‚ä¸€ä¸ª Box å‹æ ¹å°±æ— æ³•è¢« poll

```rust
let a = Box::new(Box::new(async {}));
let mut b = Pin::new(a);
let c = b.as_mut().get_mut();
```


## ä¸‰. å°ç»“

ä½¿ç”¨ Pin ä¸»è¦æ˜¯ä¸ºäº†é¿å…è‡ªå¼•ç”¨ Future çš„ç§»åŠ¨é—®é¢˜ï¼Œæ ¸å¿ƒä¼šå…³æ³¨ä¸¤ç‚¹ï¼š
1. æ˜¯å¦åˆ†é…åœ¨å †ä¸Š
2. åœ¨ç»™å‡ºäº† Pin<&mut Self> ä¹‹åï¼Œæ˜¯å¦èƒ½å®‰å…¨åœ°è·å–åˆ° &mut Self

å‰è€…é¢å‘ executorï¼Œåè€…é¢å‘ reactor  

## 3.1 ç¬¬ä¸€ä¸ªé—®é¢˜ï¼ŒHeap or Stack?  

```rust
// 1. Pin to the heap 

// Box::pin(future) : Pin<Box<T>>
// for example
let a: Pin<Box<dyn Future>> = Box::pin(future);

// 2. Pin to the stack

let f: impl Future = async {};
// pin-utils crate
pin_utils:pin_mut!(f);
f: Pin<&mut impl Future<..>>;
```

å¯¹äºä¸€ä¸ªåˆ†é…åœ¨å †ä¸Šçš„ Future æ¥è¯´ï¼Œå½“ç„¶å¯ä»¥éšæ„"ç§»åŠ¨"ï¼Œè¿™é‡Œçš„ç§»åŠ¨æŒ‡çš„æ˜¯ï¼Œ`Pin<Box<dyn Future>>` è¿™ä¸ªç»“æ„çš„æ‰€æœ‰æƒä¸ç®¡å¦‚ä½•è½¬ç§»ï¼Œè¯¥ Future çš„å†…å­˜ä¸€ç›´(Pin)åœ¨å †ä¸Šï¼Œç›´åˆ° Box è¢« Drop æ‰ä¼šè¢«é‡Šæ”¾ï¼Œæ¯”å¦‚ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œa é¦–å…ˆè¢« pollï¼Œä¸ç®¡ä¹‹åæ‰€æœ‰æƒå¦‚ä½•è½¬ç§»ï¼Œæ”¹å˜çš„ä¹Ÿåªæ˜¯æ ˆä¸Šçš„æŒ‡é’ˆä½ç½®ï¼Œè¯¥ `Box<dyn Future>` çš„å†…å®¹ä»ç„¶åœ¨å †ä¸Šï¼Œå› è€Œè‡ªå¼•ç”¨ä¹Ÿæ˜¯æœ‰æ•ˆçš„

```rust
async fn bar(){}

let a = Box::pin(aysnc{ bar().await; 1});
a.poll(...);
let b = a;
let c = b;
// ä»ç„¶æ˜¯æœ‰æ•ˆçš„
c.poll(...);
```

å¯¹äºä¸€ä¸ªåˆ†é…åœ¨æ ˆä¸Šçš„ Future æ¥è¯´ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦æ‰‹åŠ¨ Poll è¿™ä¸ª Futureï¼Œä¹Ÿéœ€è¦å°†å…¶ Pin ä½ï¼Œæ‰èƒ½æ»¡è¶³ `poll(self: Pin<&mut Self>, cx: &mut Context<'_>)` çš„æ–¹æ³•ç­¾åï¼Œæœ‰ä¸¤ç§æ–¹å¼å¯ä»¥å®ç°ï¼š
1. é€šè¿‡ unsafe ä»£ç ï¼Œ`Pin::new_unchecked(&mut a)`
2. é€šè¿‡ pin-utils è¿™ä¸ª crate æä¾›çš„ pin_mut! å®æ¥è§£å†³  

```rust
async fn bar(){}

// 1. unsafe å®ç°ï¼Œéœ€è¦æ‰‹åŠ¨ä¿è¯ a ä¸è¢« move
let mut a = bar();
let f = unsafe { Pin::new_unchecked(&mut a) };
f.poll(...);
let c = a;
f.poll(..); // BOM!

// 2. pin_mut å®å®ç°ï¼Œæ›´åŠ  clever çš„æ–¹å¼ï¼Œå›é¿äº† a è¢« move çš„å¯èƒ½
let a = bar(); // a æ˜¯åˆ†é…åœ¨æ ˆä¸Šçš„
pin_mut!(a);  // a now is Pin<&mut impl Future<Output=()>>
a.poll(...)

```

æ˜¾ç„¶ï¼Œå¯¹äºæ ˆä¸Šçš„ GenFuture æ¥è¯´ï¼Œä»…ä»…æ˜¯ `let c = a` è¿™ç§è½¬ç§»æ‰€æœ‰æƒçš„æ–¹å¼ï¼Œä¹Ÿä¼šè®© Pin<&mut ...> å¤±æ•ˆï¼Œæ ˆä¸Šçš„ Future ä¸€æ—¦å·²ç» pollï¼Œæ ¹æœ¬æ— æ³•åœ¨çº¿ç¨‹é—´è½¬ç§»ï¼Œæ›´åˆ«æè°ƒåº¦äº†ï¼Œåªæœ‰åœ¨æ²¡æœ‰å †å†…å­˜åˆ†é…çš„åµŒå…¥å¼ç³»ç»Ÿä¸­ï¼Œæ‰ä¼šå®ç°ç‰¹æ®Šçš„ runtimeï¼Œä¿è¯ä¸€å®šåœ¨ç‰¹å®šçš„ Stack ä¸Šå» poll è¿™ä¸ªå·²ç» Pin ä½çš„ Futureã€‚å› ä¸ºä¸€æ—¦ç¦»å¼€äº†è¿™ä¸ªæ‰§è¡Œæ ˆï¼Œè¿™ä¸ª Future ä¹Ÿå°±å¤±æ•ˆäº†ã€‚è€Œç¬¬äºŒç§æ–¹å¼ä¸­çš„ pin_mut!ï¼Œç”±äº Rust å«ç”Ÿå®çš„ç‰¹æ€§ï¼Œå°†å˜é‡ a è¦†ç›–äº†ï¼Œå°±æ— æ³•é€šè¿‡é™¤éå®‰å…¨ä»£ç ä¹‹å¤–çš„æ–¹å¼è·å–åˆ° `&mut a`ï¼Œä»è€Œä¿è¯å®‰å…¨æ€§ã€‚

å¯¹æ¯”äº† `Box::pin å’Œ pin_mut!`ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºä¸‹é¢çš„ç»“è®ºï¼š
- å½“éœ€è¦è¿”å›ä¸€ä¸ª Boxï¼Œæˆ–è€…è¦å°†ä¸€ä¸ª Future ä¿å­˜åœ¨ç»“æ„ä½“ä¸­ï¼Œéœ€è¦ç”¨ `Box::pin`
- å½“ç›®çš„æ˜¯åœ¨æŸä¸ªå‡½æ•°ä¸­ä½¿ç”¨ Futureï¼Œæ›´åº”è¯¥ç”¨ä¸Š pin_mut!ï¼Œå¯ä»¥èŠ‚çœ heap allocation çš„å¼€é”€

è¿™é‡Œå¿…é¡»è¦è¡¥å……ä¸€ä¸ªçŸ¥è¯†ç‚¹ï¼Œä¹Ÿå°±æ˜¯ Future çš„ä¸¤ç§æ‰§è¡Œæ–¹å¼:
1. runtime::spawn(future)   -- é¡¶å±‚ Future
2. future.await                       -- äº¤ç»™ parent Future æ‰§è¡Œ

ç¬¬ä¸€ç§æ–¹å¼ä¸­ï¼Œruntime ä¼šé¦–å…ˆå¯¹é¡¶å±‚çš„ Future åšä¸€æ¬¡å †åˆ†é…ï¼Œæˆ‘ä»¬å°±å«å®ƒ root Futureï¼Œæ— è®º root Future æ˜¯å¦æ˜¯ Unpin çš„ï¼Œ`Box<dyn Future>` ä¸€å®šå®ç°äº† Unpinï¼Œå°±å¯ä»¥äº¤ç»™ executor å®‰å…¨åœ°æ‰§è¡Œ poll äº†

ç¬¬äºŒç§æ–¹å¼ä¸­ï¼Œè¯¥ Future ä¼šè¢« parent Future(async) **æ„ŸçŸ¥**ï¼Œåœ¨è¢« grand parent æ„ŸçŸ¥...ï¼Œåˆ°æœ€åä¹Ÿä¸€å®šæ˜¯é€šè¿‡runtime::spawn æ¥æ‰§è¡Œçš„ã€‚å¦‚æœå°†å…¶è§†ä¸ºä¸€é¢— Future æ ‘ï¼Œå†…éƒ¨æ‰€æœ‰çš„å­å­™ Future éƒ½ä¼šå¤ç”¨ root Future åˆ†é…çš„ç©ºé—´ï¼Œä¹Ÿå°±æ˜¯ spawn ä¸­ä¸€æ¬¡æ€§åˆ†é…åœ¨å †ä¸Šçš„ç©ºé—´ã€‚

### 3.1 ç¬¬äºŒä¸ªé—®é¢˜ï¼Œè·å– &mut Self

é’ˆå¯¹ async/await å¾—åˆ°çš„ `Pin<&mut Future>`ï¼ŒPin å¯ä»¥ç¡®ä¿ä¸ä¼šåœ¨å®‰å…¨ä»£ç ä¸­å¾—åˆ° `&mut Future`ï¼Œä»è€Œè¢«æ»¥ç”¨ï¼›é’ˆå¯¹æ‰‹åŠ¨å®ç°ã€æ²¡æœ‰è‡ªå¼•ç”¨ç»“æ„çš„ã€é¢å‘åº•å±‚ reactor çš„ Futureï¼Œåˆ™å¯ä»¥æ²¡æœ‰ä»»ä½•ä»£ä»·åœ°è·å–åˆ° `&mut Future`ã€‚

é’ˆå¯¹ executor å’Œ reactorï¼Œæœ‰ä¸¤ç§ä¸åŒçš„ Futureï¼Œasync/await æ˜¯ high-levelï¼Œé¢å‘ executor çš„ Futureï¼Œæ‰‹åŠ¨å®ç°çš„æ˜¯ low-levelï¼Œé¢å‘ç³»ç»Ÿçš„ Futureã€‚åªæœ‰å‰è€…ä¼šå¯¼è‡´è‡ªå¼•ç”¨é—®é¢˜ï¼Œä½†æ˜¯ Rust å›¢é˜ŸèŠ±äº†è¿™ä¹ˆå¤šç²¾åŠ›å»ä¿®è¡¥å®Œå–„ï¼Œè¿™æ‰æ‹¿å‡ºäº†è¿™ä¸ªæ¯”è¾ƒå¥½ç”¨çš„ APIï¼Œå¦‚æœä¸äº†è§£è¿™äº›ï¼Œå®Œå…¨æ²¡æœ‰åŠæ³•æƒ³è±¡ï¼Œå±…ç„¶æœ‰è¿™ä¹ˆå¤šè€ƒé‡çš„å› ç´ ã€‚