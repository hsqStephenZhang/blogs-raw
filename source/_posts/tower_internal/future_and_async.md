---
title: Future async 状态机 
---

## 1. Future 是什么

在浏览本节之前，希望你可以大致了解一下 Future 设计思想的演进过程，比如 javascript 中的 Promise

那么什么是 Future？

Future 是一些将在未来完成操作的表示。

Rust 中的异步机制使用的是基于轮询（Poll）的方法，一个异步任务会有三个阶段。

1. 轮询阶段。 对一个 Future 进行轮询，推进其向前执行，直到不能再执行下去（被阻塞）。我们常把运行时中对 Future 进行轮询的部分称为执行器（executor）。
2. 等待阶段。 一个事件源，最常被称为反应器（reactor），它注册一个 Future 正在等待一个事件的发生，并确保在该事件准备好时，它将唤醒 Future。
3. 唤醒阶段。 事件发生了，Future 被唤醒了。现在，在第 1 步中轮询 Future 的执行器要安排 Future 再次被轮询，并继续推进其执行，直到它完成或达到一个新的阻塞点，重复这个循环。

你可能对上面的一些术语不是很清楚，接下来我会慢慢解释。

### 1.1 Executor

首先，你可以大致将 executor 看成是 `future queue + poll loop`，它的任务就是不断从 future 队列中取出 future，然后执行 poll 方法。如果想要创建一个最简单的 executor，其实异常简单，基本上就是一个 loop 循环，但是如果想要高效地进行调度，那就需要利用到很多优化算法了。

```rust
loop {
    while let Some(f) = receiver.recv() {
        f.poll(...);
        ...
    }
}
```

### 1.2 Reactor

reactor 是真正和系统层面打交道的组件，各个操作系统的底层，几乎都采用了事件驱动的 IO 多路复用模型，在 Linux 上是 epoll，而在 windows 和 macOS 这种成熟的系统上，也分别有 iocp 和 kqueue。它们本质上做了这件事：当某一次操作依赖于某些资源的时候，需要向操作系统注册，告诉系统：等这个资源准备好之后，再来通知我，否则将我挂起。

其实系统的阻塞 API 也是完成了这件事情，比如 socket 默认就是阻塞的模型，当 accept 一个 socket 的时候，整个进程都有可能陷入阻塞状态，造成当前进程无法充分利用 CPU。但是 epoll 这种 IO 多路复用的模型，其实可以通过一个红黑树，高效地帮助我们监听多个文件描述符，每次从内核返回，会将所有的 ready 状态的描述符都返回给用户，达到了 batch 操作的效果。

### 1.3 executor + reactor

可以想象，如果是一个既涉及 CPU 计算，也要涉及底层 IO 的 future，其实会不断地在 executor 和 reactor 之间轮转：需要计算时，交给 executor 执行，需要 IO 的时候，交给 reactor，由 reactor 负责事件通知，资源准备好了之后，又交给 executor 执行，循环往复，直到该 future 执行完毕。

## 2. Leaf Future VS Non-Leaf Future

上面提到，future 可以区分为 `CPU/IO` 两种类型，那么反映在其创建方式上，又是什么样的呢？

future 有两种实现方式，一种是手动为某一个类型实现 `Future trait`，另一种是通过 async/await 关键字创建，分别对应 Leaf-future 和 Non-leaf-future（后面会解释为什么这样取名）。

### 2.1 叶子 Futures

先来看 Leaf Futures，它们代表系统中的 IO 资源，比如 socket，file，timer。

```rust
// stream is a leaf-future
let mut stream = tokio::net::TcpStream::connect("127.0.0.1:3000");
```

对 IO 资源的操作，比如对 socket 的 Read 将是非阻塞的，并返回一个 future，称之为叶子 future。之所以要求非阻塞，是因为只有这样，才能将所有权牢牢抓在用户态的 runtime 手里，否则一旦阻塞，当前进程就会被操作系统调度出去，效率就降低了。

除非你要写一个 runtime，否则你不太可能自己实现一个叶子 Future，或者更多的是针对 Leaf-Future 的封装。

<!-- 你也不太可能将一个叶子 Future 传给一个 runtime 然后单独运行完成，你读了下一段就会明白。 -->

### 2.2 非叶子 Futures

Non-leaf-futures 是指作为 runtime 的用户，使用 async 关键字自己编写的 Futures，用于创建一个可以在执行器上运行的任务。

一个异步程序大部分由非叶子 Futures 组成，它是一种可暂停的计算。这是一个重要的区别，因为这些 Futures 代表了一组操作。通常，这样的任务会等待（await）一个叶子 Future 作为完成任务的许多操作之一。

```rust
// Non-leaf-future
let non_leaf = async {
    let mut stream = TcpStream::connect("127.0.0.1:3000").await.unwrap();// <- yield
    println!("connected!");
    let result = stream.write(b"hello world\n").await; // <- yield
    println!("message sent!");
    ...
};
```

## 2. async 状态机

大家可能都知道，rust 中的 future 状态机，这个其实是 async 的基石，也导致了后续的一系列问题。

async/await 其实是一对语法糖，`async fn a() -> T {...}` 会被 rust 解释为 `fn a()-> impl Future<Output = T> {...}`，也就是说，一个 async 函数会被翻译为 Future，这个 Future 有没有什么特殊之处呢？

其实，Rust 中专门有一个 GenFuture 类型，对应编译器为 async 代码块生成的 Future，代码块中的程序执行，会被翻译为状态机的状态转移。

如果将 future 看成是一个树状结构，那么消耗一个 future，其实就是在遍历这颗 future 树，交给 executor 执行的其实是 root future，根据内部的 non-leaf-future 来生成状态机，根据 leaf-future 判定状态机是否需要 Pending。

一个 Future 在某个时刻只会都只有唯一的状态，因此，可以用 enum 表示，为每一个可能存在的状态，都生成一个对应的 State，比如下面的 `AsyncState`，这样，我们只需要为 future 分配状态最大需要占用的内存，其余的状态下，都可以复用这块空间。理论上来说，这是最高效的模型了。


```rust
async fn root_future(){
    let fut_one = /* ... */;
    let fut_two = /* ... */;
    async move {
        fut_one.await;
        fut_two.await;
    }.await
}
```

```rust
// The `Future` type generated by our `async { ... }` block
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: AsyncState,
}

// List of states our `async` block can be in
enum AsyncState {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.state {
                AsyncState::AwaitingFutOne => match self.fut_one.poll(..) {
                    Poll::Ready(()) => self.state = AsyncState::AwaitingFutTwo,
                    Poll::Pending => return Poll::Pending,
                }
                AsyncState::AwaitingFutTwo => match self.fut_two.poll(..) {
                    Poll::Ready(()) => self.state = AsyncState::Done,
                    Poll::Pending => return Poll::Pending,
                }
                AsyncState::Done => return Poll::Ready(()),
            }
        }
    }
}

```

future 的根其实就是交给 runtime 进行 spawn 的最顶层 future，而其内部，其实包含了多个 `async/await future` + `io future`，编译器为 async/await 生成为内部的非叶子结点 GenFuture，作为 Non-leaf-future 在 executor 上执行，而我们面向底层 Io 实现的 future，则是作为 leaf-future 在 reactor 上执行。
